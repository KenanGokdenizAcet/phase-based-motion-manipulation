// SteerablePyramidDecompose.compute
// Decomposes an image into steerable pyramid representation

#pragma kernel DecomposeLevel
#pragma kernel ExtractResidualLowPass
#pragma kernel ExtractResidualHighPass
#pragma kernel ConvertToFrequencyDomain
#pragma kernel ConvertToSpatialDomain

#define GROUP_SIZE 32
#define PI 3.14159265359

// Input/Output
Texture2D<float> _InputTexture;
Texture2D<float2> _InputDFT; // RG = real, imaginary
RWTexture2D<float> _OutputTexture;
RWTexture2D<float2> _OutputDFT;
RWTexture2D<float4> _PyramidLevel; // Multiple orientations

// Filters
Texture2D<float> _LowPassFilter;
Texture2D<float> _HighPassFilter;
Texture2D<float4> _BandPassFilter;

// Parameters
int _Width;
int _Height;
int _ScaleIndex;
int _NumOrientations;
float _Gain; // Gain factor for reconstruction

// Complex multiplication
float2 ComplexMultiply(float2 a, float2 b)
{
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

// Apply filter in frequency domain and store multiple orientations
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void DecomposeLevel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    // Read input DFT
    float2 inputDFT = _InputDFT[id.xy];
    
    // Read band-pass filters for this position
    float4 filters = _BandPassFilter[id.xy];
    
    // Apply each oriented filter
    float4 filtered;
    filtered.r = ComplexMultiply(inputDFT, float2(filters.r, 0)).x; // Real part only for now
    filtered.g = ComplexMultiply(inputDFT, float2(filters.g, 0)).x;
    filtered.b = ComplexMultiply(inputDFT, float2(filters.b, 0)).x;
    filtered.a = ComplexMultiply(inputDFT, float2(filters.a, 0)).x;
    
    // Store filtered results
    _PyramidLevel[id.xy] = filtered * _Gain;
}

// Extract low-pass residual
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void ExtractResidualLowPass(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    float2 inputDFT = _InputDFT[id.xy];
    float lowPassFilter = _LowPassFilter[id.xy];
    
    // Apply low-pass filter
    float2 filtered = ComplexMultiply(inputDFT, float2(lowPassFilter, 0));
    
    _OutputDFT[id.xy] = filtered;
}

// Extract high-pass residual
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void ExtractResidualHighPass(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    float2 inputDFT = _InputDFT[id.xy];
    float highPassFilter = _HighPassFilter[id.xy];
    
    // Apply high-pass filter
    float2 filtered = ComplexMultiply(inputDFT, float2(highPassFilter, 0));
    
    _OutputDFT[id.xy] = filtered;
}

// Helper: Convert spatial domain to frequency domain (for interfacing with existing FFT)
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void ConvertToFrequencyDomain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    // This is a placeholder - actual FFT is handled by existing compute shader
    float value = _InputTexture[id.xy];
    _OutputDFT[id.xy] = float2(value, 0);
}

// Helper: Convert frequency domain to spatial domain
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void ConvertToSpatialDomain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    // This is a placeholder - actual IFFT is handled by existing compute shader
    float2 value = _InputDFT[id.xy];
    _OutputTexture[id.xy] = value.x; // Real part
}