// SteerablePyramidReconstruct.compute
// Reconstructs image from steerable pyramid representation

#pragma kernel AccumulatePyramidLevel
#pragma kernel AddResiduals
#pragma kernel ProcessPhaseDifferencePerLevel
#pragma kernel InitializeReconstruction

#define GROUP_SIZE 32
#define PI 3.14159265359

// Pyramid levels and residuals
Texture2D<float4> _CurrentPyramidLevel;
Texture2D<float4> _PreviousPyramidLevel;
Texture2D<float2> _LowPassResidualDFT;
Texture2D<float2> _HighPassResidualDFT;

// Filters for reconstruction
Texture2D<float> _LowPassFilter;
Texture2D<float> _HighPassFilter;
Texture2D<float4> _BandPassFilter;

// Accumulation buffer for reconstruction
RWTexture2D<float2> _ReconstructionDFT;
RWTexture2D<float4> _ProcessedPyramidLevel;

// Parameters
int _Width;
int _Height;
int _ScaleIndex;
int _NumOrientations;
float _PhaseScale;
float _MagnitudeThreshold;
int _AddHighPass; // Whether to add high-pass residual

// Complex operations
float2 ComplexMultiply(float2 a, float2 b)
{
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

float2 ComplexFromPolar(float magnitude, float phase)
{
    return float2(magnitude * cos(phase), magnitude * sin(phase));
}

float ComplexMagnitude(float2 z)
{
    return sqrt(z.x * z.x + z.y * z.y);
}

float ComplexPhase(float2 z)
{
    return atan2(z.y, z.x);
}

float NormalizePhase(float phase)
{
    while (phase > PI) phase -= 2.0 * PI;
    while (phase < -PI) phase += 2.0 * PI;
    return phase;
}

// Initialize reconstruction buffer
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void InitializeReconstruction(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    _ReconstructionDFT[id.xy] = float2(0, 0);
}

// Process phase difference for each orientation in pyramid level
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void ProcessPhaseDifferencePerLevel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    // Read current and previous pyramid levels
    float4 currentLevel = _CurrentPyramidLevel[id.xy];
    float4 previousLevel = _PreviousPyramidLevel[id.xy];
    
    // Read band-pass filters
    float4 filters = _BandPassFilter[id.xy];
    
    float4 processedLevel = float4(0, 0, 0, 0);
    
    // Process each orientation
    for (int i = 0; i < min(_NumOrientations, 4); i++)
    {
        float currentValue, previousValue, filterValue;
        
        // Select appropriate channel
        if (i == 0) {
            currentValue = currentLevel.r;
            previousValue = previousLevel.r;
            filterValue = filters.r;
        } else if (i == 1) {
            currentValue = currentLevel.g;
            previousValue = previousLevel.g;
            filterValue = filters.g;
        } else if (i == 2) {
            currentValue = currentLevel.b;
            previousValue = previousLevel.b;
            filterValue = filters.b;
        } else {
            currentValue = currentLevel.a;
            previousValue = previousLevel.a;
            filterValue = filters.a;
        }
        
        // Convert to complex representation (assuming real values for now)
        float2 currentComplex = float2(currentValue, 0);
        float2 previousComplex = float2(previousValue, 0);
        
        float currentMag = abs(currentValue);
        float previousMag = abs(previousValue);
        
        // Check magnitude threshold
        if (currentMag < _MagnitudeThreshold || previousMag < _MagnitudeThreshold)
        {
            // Keep original value
            if (i == 0) processedLevel.r = currentValue;
            else if (i == 1) processedLevel.g = currentValue;
            else if (i == 2) processedLevel.b = currentValue;
            else processedLevel.a = currentValue;
            continue;
        }
        
        // Calculate phase difference
        float currentPhase = sign(currentValue) * PI * 0.5; // Simplified for real values
        float previousPhase = sign(previousValue) * PI * 0.5;
        float phaseDelta = NormalizePhase(previousPhase - currentPhase);
        
        // Apply phase magnification
        float modifiedPhase = phaseDelta * _PhaseScale;
        
        // Apply modification
        float modifiedValue = currentValue * cos(modifiedPhase);
        
        // Store in appropriate channel
        if (i == 0) processedLevel.r = modifiedValue;
        else if (i == 1) processedLevel.g = modifiedValue;
        else if (i == 2) processedLevel.b = modifiedValue;
        else processedLevel.a = modifiedValue;
    }
    
    _ProcessedPyramidLevel[id.xy] = processedLevel;
}

// Accumulate pyramid level into reconstruction
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void AccumulatePyramidLevel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    // Read processed pyramid level
    float4 pyramidLevel = _ProcessedPyramidLevel[id.xy];
    
    // Read band-pass filters
    float4 filters = _BandPassFilter[id.xy];
    
    // Accumulate contribution from each orientation
    float2 contribution = float2(0, 0);
    
    for (int i = 0; i < min(_NumOrientations, 4); i++)
    {
        float levelValue, filterValue;
        
        if (i == 0) {
            levelValue = pyramidLevel.r;
            filterValue = filters.r;
        } else if (i == 1) {
            levelValue = pyramidLevel.g;
            filterValue = filters.g;
        } else if (i == 2) {
            levelValue = pyramidLevel.b;
            filterValue = filters.b;
        } else {
            levelValue = pyramidLevel.a;
            filterValue = filters.a;
        }
        
        // Apply filter and accumulate
        contribution += float2(levelValue * filterValue, 0);
    }
    
    // Add to reconstruction
    float2 current = _ReconstructionDFT[id.xy];
    _ReconstructionDFT[id.xy] = current + contribution;
}

// Add low-pass and high-pass residuals
[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void AddResiduals(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Width || id.y >= (uint)_Height)
        return;
    
    float2 reconstruction = _ReconstructionDFT[id.xy];
    
    // Add low-pass residual
    float2 lowPassResidual = _LowPassResidualDFT[id.xy];
    float lowPassFilter = _LowPassFilter[id.xy];
    reconstruction += ComplexMultiply(lowPassResidual, float2(lowPassFilter, 0));
    
    // Optionally add high-pass residual
    if (_AddHighPass > 0)
    {
        float2 highPassResidual = _HighPassResidualDFT[id.xy];
        float highPassFilter = _HighPassFilter[id.xy];
        reconstruction += ComplexMultiply(highPassResidual, float2(highPassFilter, 0));
    }
    
    _ReconstructionDFT[id.xy] = reconstruction;
}