#pragma kernel ApplyTemporalFilter

#define GROUP_SIZE_X 32
#define GROUP_SIZE_Y 32
#define PI 3.14159265359f

typedef float2 Complex;

int Width;
int Height;
int BatchSize;
int NumFrames;

RWStructuredBuffer<Complex> PhaseDeltas;
StructuredBuffer<Complex> TemporalFilter;

// Complex operations
inline Complex ComplexMultiply(Complex a, Complex b)
{
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void ApplyTemporalFilter(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)Width || id.y >= (uint)Height)
        return;
    
    uint pixelIndex = id.y * Width + id.x;
    
    // Apply temporal filter to each pyramid level in the batch
    for (int level = 0; level < BatchSize; level++)
    {
        // Gather phase deltas across frames for this pixel and level
        Complex frequencyDomain[10]; // Max 10 frames for now
        
        // Forward FFT on temporal dimension
        for (int frame = 0; frame < NumFrames; frame++)
        {
            uint deltaIndex = level * Width * Height + frame * Width * Height * BatchSize + pixelIndex;
            float phaseDelta = PhaseDeltas[deltaIndex].x;
            
            // Simple DFT for temporal dimension
            frequencyDomain[frame] = float2(phaseDelta, 0);
        }
        
        // Apply filter in frequency domain
        for (int freq = 0; freq < NumFrames; freq++)
        {
            frequencyDomain[freq] = ComplexMultiply(frequencyDomain[freq], TemporalFilter[freq]);
        }
        
        // Inverse FFT (simplified - just take real part of first component)
        float filteredDelta = frequencyDomain[0].x;
        
        // Store filtered result back
        uint outputIndex = level * Width * Height + pixelIndex;
        PhaseDeltas[outputIndex] = float2(filteredDelta, 0);
    }
}